This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, line numbers have been added.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*
- Files matching these patterns are excluded: **/*.log, **/uv.lock, **/package-lock.json, **/.env, **/Cargo.lock, **/node_modules, **/target, **/dist, **/build, **/output.txt, **/yarn.lock, **/uv.lock, **/package-lock.json, **/.env, **/Cargo.lock, **/node_modules, **/target, **/dist, **/build, **/output.txt, **/yarn.lock
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
src/
  bin/
    main.rs
  cache.rs
  client.rs
  config.rs
  error.rs
  lib.rs
  main.rs
tests/
  basic_test.rs
  cache_test.rs
  client_test.rs
  config_test.rs
  smoke_test.rs
.env.example
.gitignore
.pre-commit-config.yaml
Cargo.toml
CLAUDE.md
prompt_plan.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
 1: {
 2:   "permissions": {
 3:     "allow": [
 4:       "Bash(mkdir:*)",
 5:       "Bash(cargo test)",
 6:       "Bash(git add:*)",
 7:       "Bash(git commit:*)",
 8:       "Bash(cargo test:*)",
 9:       "Bash(grep:*)",
10:       "Bash(cargo doc:*)",
11:       "WebFetch(domain:docs.rs)"
12:     ],
13:     "deny": []
14:   }
15: }
</file>

<file path="src/bin/main.rs">
  1: // ABOUTME: Main executable for the Transparent Classroom Photos Grabber
  2: // ABOUTME: Provides CLI interface for downloading photos
  3: use std::env;
  4: use std::path::PathBuf;
  5: use std::process;
  6: use log::{debug, error, info};
  7: use transparent_classroom_photos_grabber_rs::{client::Client, config::Config, error::AppError};
  8: fn main() {
  9:     // Initialize the library (sets up logging)
 10:     transparent_classroom_photos_grabber_rs::init();
 11:     // Parse command-line arguments
 12:     let args: Vec<String> = env::args().collect();
 13:     if args.len() > 1 && (args[1] == "-h" || args[1] == "--help") {
 14:         print_usage();
 15:         return;
 16:     }
 17:     // Get the output directory from args or use default
 18:     let output_dir = if args.len() > 1 {
 19:         PathBuf::from(&args[1])
 20:     } else {
 21:         PathBuf::from("./photos")
 22:     };
 23:     // Run the application
 24:     if let Err(e) = run(output_dir) {
 25:         error!("Application error: {}", e);
 26:         eprintln!("Error: {}", e);
 27:         process::exit(1);
 28:     }
 29: }
 30: fn print_usage() {
 31:     println!("Transparent Classroom Photos Grabber");
 32:     println!("Usage: transparent-classroom-photos-grabber [OUTPUT_DIR]");
 33:     println!();
 34:     println!("If OUTPUT_DIR is not provided, photos will be saved to './photos'");
 35:     println!();
 36:     println!("Environment variables:");
 37:     println!("  TC_EMAIL     - Your Transparent Classroom email");
 38:     println!("  TC_PASSWORD  - Your Transparent Classroom password");
 39:     println!("  SCHOOL       - Your school ID");
 40:     println!("  CHILD        - Your child ID");
 41:     println!();
 42:     println!("Example:");
 43:     println!("  export TC_EMAIL=yourname@example.com");
 44:     println!("  export TC_PASSWORD=yourpassword");
 45:     println!("  export SCHOOL=12345");
 46:     println!("  export CHILD=67890");
 47:     println!("  transparent-classroom-photos-grabber ./my-photos");
 48: }
 49: fn run(output_dir: PathBuf) -> Result<(), AppError> {
 50:     // Load configuration from environment
 51:     info!("Loading configuration from environment");
 52:     let config = Config::from_env()?;
 53:     debug!("Loaded configuration with school ID: {}", config.school_id);
 54:     // Create the client
 55:     info!("Creating client and logging in");
 56:     let client = Client::new(config)?;
 57:     // Login to Transparent Classroom
 58:     client.login()?;
 59:     info!("Successfully logged in");
 60:     // Fetch posts (page 0 = most recent)
 61:     info!("Fetching recent posts");
 62:     let posts = client.get_posts(0)?;
 63:     if posts.is_empty() {
 64:         info!("No posts found");
 65:         println!("No posts found");
 66:         return Ok(());
 67:     }
 68:     info!("Found {} posts", posts.len());
 69:     println!("Found {} posts", posts.len());
 70:     // Create the output directory if it doesn't exist
 71:     if !output_dir.exists() {
 72:         info!("Creating output directory: {}", output_dir.display());
 73:         std::fs::create_dir_all(&output_dir)?;
 74:     }
 75:     // Download photos for each post
 76:     let mut total_photos = 0;
 77:     info!("Downloading photos to {}", output_dir.display());
 78:     for (i, post) in posts.iter().enumerate() {
 79:         println!(
 80:             "Processing post {}/{}: '{}'",
 81:             i + 1,
 82:             posts.len(),
 83:             post.title
 84:         );
 85:         if post.photo_urls.is_empty() {
 86:             debug!("Post '{}' has no photos, skipping", post.title);
 87:             continue;
 88:         }
 89:         debug!(
 90:             "Downloading {} photos from post '{}'",
 91:             post.photo_urls.len(),
 92:             post.title
 93:         );
 94:         // Create a subdirectory for this post
 95:         let post_dir = output_dir.join(format!("post_{}_{}", i + 1, sanitize_dirname(&post.title)));
 96:         // Download all photos for this post
 97:         match client.download_all_photos(post, &post_dir) {
 98:             Ok(paths) => {
 99:                 let count = paths.len();
100:                 total_photos += count;
101:                 println!("  Downloaded {} photos", count);
102:             }
103:             Err(e) => {
104:                 error!("Failed to download photos for post '{}': {}", post.title, e);
105:                 println!("  Failed to download photos: {}", e);
106:                 // Continue with other posts
107:             }
108:         }
109:     }
110:     info!(
111:         "Download complete. Downloaded {} photos from {} posts",
112:         total_photos,
113:         posts.len()
114:     );
115:     println!(
116:         "\nDownload complete! Downloaded {} photos from {} posts",
117:         total_photos,
118:         posts.len()
119:     );
120:     println!("Photos saved to: {}", output_dir.display());
121:     Ok(())
122: }
123: // Helper function to sanitize directory names
124: fn sanitize_dirname(input: &str) -> String {
125:     let mut result = input.trim().to_owned();
126:     // Replace spaces with underscores
127:     result = result.replace(' ', "_");
128:     // Remove characters that are problematic in directory names
129:     result = result.replace(
130:         &['/', '\\', ':', '*', '?', '"', '<', '>', '|', '\''][..],
131:         "",
132:     );
133:     // Truncate if too long
134:     if result.len() > 30 {
135:         result.truncate(30);
136:     }
137:     result
138: }
</file>

<file path="src/cache.rs">
  1: // ABOUTME: Caching implementation for Transparent Classroom API responses
  2: // ABOUTME: Provides functionality to read and write cached data to disk as JSON
  3: use log::{debug, info, warn};
  4: use serde::{Deserialize, Serialize};
  5: use std::fs::{self, File};
  6: use std::io::{BufReader, BufWriter};
  7: use std::path::{Path, PathBuf};
  8: use std::time::{Duration, SystemTime};
  9: use crate::error::AppError;
 10: /// Represents a cached item with timestamp
 11: #[derive(Debug, Serialize, Deserialize)]
 12: pub struct CacheData<T> {
 13:     /// When the data was stored
 14:     pub timestamp: SystemTime,
 15:     /// The actual payload data
 16:     pub payload: T,
 17: }
 18: /// Configuration for the cache behavior
 19: #[derive(Debug, Clone, Copy)]
 20: pub struct CacheConfig {
 21:     /// Maximum age of cache data in seconds
 22:     pub max_age_secs: u64,
 23:     /// Whether to create the cache directory if it doesn't exist
 24:     pub create_dirs: bool,
 25: }
 26: impl Default for CacheConfig {
 27:     fn default() -> Self {
 28:         Self {
 29:             max_age_secs: 60 * 60, // 1 hour by default
 30:             create_dirs: true,
 31:         }
 32:     }
 33: }
 34: /// Read cached data from disk
 35: ///
 36: /// Returns:
 37: /// - `Ok(Some(data))` if valid cache exists and isn't expired
 38: /// - `Ok(None)` if cache doesn't exist or is expired
 39: /// - `Err(_)` if there's an error reading or parsing the cache
 40: pub fn read_cache<T>(path: &Path, config: CacheConfig) -> Result<Option<CacheData<T>>, AppError>
 41: where
 42:     T: for<'de> Deserialize<'de>,
 43: {
 44:     debug!("Attempting to read cache from: {}", path.display());
 45:     // Check if the cache file exists
 46:     if !path.exists() {
 47:         debug!("Cache file doesn't exist at: {}", path.display());
 48:         return Ok(None);
 49:     }
 50:     // Open and read the cache file
 51:     let file = match File::open(path) {
 52:         Ok(file) => file,
 53:         Err(e) => {
 54:             warn!("Failed to open cache file at {}: {}", path.display(), e);
 55:             return Err(AppError::Io(e));
 56:         }
 57:     };
 58:     let reader = BufReader::new(file);
 59:     // Parse the JSON
 60:     let cache_data: CacheData<T> = match serde_json::from_reader(reader) {
 61:         Ok(data) => data,
 62:         Err(e) => {
 63:             warn!("Failed to parse cache data from {}: {}", path.display(), e);
 64:             return Err(AppError::Generic(format!("Failed to parse cache: {}", e)));
 65:         }
 66:     };
 67:     // Check if the cache is expired
 68:     let now = SystemTime::now();
 69:     let max_age = Duration::from_secs(config.max_age_secs);
 70:     match now.duration_since(cache_data.timestamp) {
 71:         Ok(age) if age > max_age => {
 72:             debug!(
 73:                 "Cache at {} is expired (age: {:?}, max: {:?})",
 74:                 path.display(),
 75:                 age,
 76:                 max_age
 77:             );
 78:             Ok(None)
 79:         }
 80:         Ok(age) => {
 81:             debug!("Using cache from {} (age: {:?})", path.display(), age);
 82:             Ok(Some(cache_data))
 83:         }
 84:         Err(e) => {
 85:             warn!(
 86:                 "Cache timestamp is in the future at {}: {}",
 87:                 path.display(),
 88:                 e
 89:             );
 90:             Ok(None)
 91:         }
 92:     }
 93: }
 94: /// Write data to cache on disk
 95: ///
 96: /// Stores the data with the current timestamp in JSON format
 97: pub fn write_cache<T>(path: &Path, data: T, config: CacheConfig) -> Result<(), AppError>
 98: where
 99:     T: Serialize,
100: {
101:     debug!("Writing cache to: {}", path.display());
102:     // Create parent directories if they don't exist and it's requested
103:     if config.create_dirs {
104:         if let Some(parent) = path.parent() {
105:             if !parent.exists() {
106:                 debug!("Creating cache directory: {}", parent.display());
107:                 fs::create_dir_all(parent).map_err(|e| {
108:                     warn!(
109:                         "Failed to create cache directory at {}: {}",
110:                         parent.display(),
111:                         e
112:                     );
113:                     AppError::Io(e)
114:                 })?;
115:             }
116:         }
117:     }
118:     // Create the cache data with current timestamp
119:     let cache_data = CacheData {
120:         timestamp: SystemTime::now(),
121:         payload: data,
122:     };
123:     // Write the JSON to file
124:     let file = match File::create(path) {
125:         Ok(file) => file,
126:         Err(e) => {
127:             warn!("Failed to create cache file at {}: {}", path.display(), e);
128:             return Err(AppError::Io(e));
129:         }
130:     };
131:     let writer = BufWriter::new(file);
132:     match serde_json::to_writer_pretty(writer, &cache_data) {
133:         Ok(()) => {
134:             info!("Successfully wrote cache to: {}", path.display());
135:             Ok(())
136:         }
137:         Err(e) => {
138:             warn!("Failed to write cache data to {}: {}", path.display(), e);
139:             Err(AppError::Generic(format!("Failed to write cache: {}", e)))
140:         }
141:     }
142: }
143: /// Get the default cache directory
144: pub fn default_cache_dir() -> PathBuf {
145:     if let Some(cache_dir) = dirs::cache_dir() {
146:         cache_dir.join("transparent-classroom-cache")
147:     } else {
148:         PathBuf::from("./.cache/transparent-classroom-cache")
149:     }
150: }
</file>

<file path="src/config.rs">
 1: // ABOUTME: Configuration management for Transparent Classroom API
 2: // ABOUTME: Loads settings from environment variables or config file
 3: use dotenv::dotenv;
 4: use log::{debug, warn};
 5: use std::env;
 6: use thiserror::Error;
 7: use crate::error::AppError;
 8: #[derive(Debug, Clone, PartialEq, Eq)]
 9: pub struct Config {
10:     pub email: String,
11:     pub password: String,
12:     pub school_id: u32,
13:     pub child_id: u32,
14: }
15: #[derive(Error, Debug)]
16: pub enum ConfigError {
17:     #[error("Missing environment variable: {0}")]
18:     MissingEnv(String),
19:     #[error("Invalid integer value for environment variable {0}: {1}")]
20:     InvalidInteger(String, #[source] std::num::ParseIntError),
21:     #[error("Environment error: {0}")]
22:     EnvError(#[from] env::VarError),
23: }
24: impl Config {
25:     /// Load configuration from environment variables
26:     ///
27:     /// If environment variables are not set, attempts to load from .env file
28:     pub fn from_env() -> Result<Self, AppError> {
29:         // Load from .env file if present (in production)
30:         Self::from_env_with_dotenv(true).map_err(AppError::Config)
31:     }
32:     /// Load configuration from environment variables with option to skip dotenv
33:     ///
34:     /// This is useful for testing where we don't want to load from .env
35:     pub fn from_env_with_dotenv(use_dotenv: bool) -> Result<Self, ConfigError> {
36:         // Check if dotenv is disabled via environment variable - useful for tests
37:         let dotenv_disabled = env::var("DOTENV_DISABLED").is_ok();
38:         // Try to load from .env file if requested and not disabled
39:         if use_dotenv && !dotenv_disabled {
40:             match dotenv() {
41:                 Ok(_) => debug!("Loaded configuration from .env file"),
42:                 Err(_) => warn!("No .env file found, using environment variables only"),
43:             }
44:         } else if dotenv_disabled {
45:             debug!("Dotenv loading disabled by DOTENV_DISABLED environment variable");
46:         }
47:         // Extract required environment variables
48:         let email =
49:             env::var("TC_EMAIL").map_err(|_| ConfigError::MissingEnv("TC_EMAIL".to_string()))?;
50:         let password = env::var("TC_PASSWORD")
51:             .map_err(|_| ConfigError::MissingEnv("TC_PASSWORD".to_string()))?;
52:         let school_id_str =
53:             env::var("SCHOOL").map_err(|_| ConfigError::MissingEnv("SCHOOL".to_string()))?;
54:         let child_id_str =
55:             env::var("CHILD").map_err(|_| ConfigError::MissingEnv("CHILD".to_string()))?;
56:         // Parse numeric values
57:         let school_id = school_id_str
58:             .parse::<u32>()
59:             .map_err(|e| ConfigError::InvalidInteger("SCHOOL".to_string(), e))?;
60:         let child_id = child_id_str
61:             .parse::<u32>()
62:             .map_err(|e| ConfigError::InvalidInteger("CHILD".to_string(), e))?;
63:         let config = Config {
64:             email,
65:             password,
66:             school_id,
67:             child_id,
68:         };
69:         debug!("Configuration loaded successfully");
70:         Ok(config)
71:     }
72: }
</file>

<file path="src/error.rs">
 1: // ABOUTME: Error types for transparent-classroom-photos-grabber-rs
 2: // ABOUTME: Centralizes all error handling for the application
 3: use thiserror::Error;
 4: /// Application-wide error type
 5: #[derive(Error, Debug)]
 6: pub enum AppError {
 7:     /// Configuration errors
 8:     #[error("Configuration error: {0}")]
 9:     Config(#[from] crate::config::ConfigError),
10:     /// Environment variable errors
11:     #[error("Environment error: {0}")]
12:     Env(#[from] std::env::VarError),
13:     /// Errors from the IO subsystem
14:     #[error("IO error: {0}")]
15:     Io(#[from] std::io::Error),
16:     /// Parsing errors
17:     #[error("Parse error: {0}")]
18:     Parse(String),
19:     /// Generic application errors
20:     #[error("{0}")]
21:     Generic(String),
22: }
23: /// Create a new generic error with a message
24: pub fn generic_error<S: Into<String>>(message: S) -> AppError {
25:     AppError::Generic(message.into())
26: }
</file>

<file path="tests/cache_test.rs">
  1: use serde::{Deserialize, Serialize};
  2: use std::fs;
  3: use std::time::{Duration, SystemTime};
  4: use tempfile::TempDir;
  5: use transparent_classroom_photos_grabber_rs::cache::{
  6:     read_cache, write_cache, CacheConfig, CacheData,
  7: };
  8: // Example struct to use for testing
  9: #[derive(Debug, Serialize, Deserialize, PartialEq)]
 10: struct Post {
 11:     id: u32,
 12:     title: String,
 13:     content: String,
 14: }
 15: // Create a temporary directory to store test cache files
 16: fn setup_temp_dir() -> TempDir {
 17:     TempDir::new().expect("Failed to create temporary directory")
 18: }
 19: // Helper function to create a test post
 20: fn create_test_post() -> Post {
 21:     Post {
 22:         id: 42,
 23:         title: "Test Post".to_string(),
 24:         content: "This is a test post for caching".to_string(),
 25:     }
 26: }
 27: #[test]
 28: fn test_write_and_read_cache() {
 29:     // Create a temporary directory for testing
 30:     let temp_dir = setup_temp_dir();
 31:     let cache_path = temp_dir.path().join("test_cache.json");
 32:     // Create test data
 33:     let post = create_test_post();
 34:     // Write data to cache
 35:     let config = CacheConfig::default();
 36:     write_cache(&cache_path, &post, config).expect("Failed to write cache");
 37:     // Verify file was created
 38:     assert!(cache_path.exists(), "Cache file was not created");
 39:     // Read data from cache
 40:     let cached_data = read_cache::<Post>(&cache_path, config).expect("Failed to read cache");
 41:     // Verify the data was read correctly
 42:     assert!(cached_data.is_some(), "Expected Some(CacheData), got None");
 43:     let cache_data = cached_data.unwrap();
 44:     assert_eq!(
 45:         cache_data.payload, post,
 46:         "Cached data doesn't match original"
 47:     );
 48:     // Verify the timestamp is recent
 49:     let now = SystemTime::now();
 50:     let age = now
 51:         .duration_since(cache_data.timestamp)
 52:         .expect("Cache timestamp is in the future");
 53:     assert!(age < Duration::from_secs(5), "Cache timestamp is too old");
 54: }
 55: #[test]
 56: fn test_cache_expiry() {
 57:     // Create a temporary directory for testing
 58:     let temp_dir = setup_temp_dir();
 59:     let cache_path = temp_dir.path().join("expired_cache.json");
 60:     // Create test data
 61:     let post = create_test_post();
 62:     // Create a manual cache with an expired timestamp
 63:     // 2 hours in the past
 64:     let two_hours = Duration::from_secs(2 * 60 * 60);
 65:     let old_timestamp = SystemTime::now()
 66:         .checked_sub(two_hours)
 67:         .expect("Failed to create timestamp");
 68:     let cache_data = CacheData {
 69:         timestamp: old_timestamp,
 70:         payload: post,
 71:     };
 72:     // Write the expired cache directly
 73:     let json = serde_json::to_string_pretty(&cache_data).expect("Failed to serialize cache data");
 74:     fs::write(&cache_path, json).expect("Failed to write cache file");
 75:     // Try to read the cache with default config (1 hour max age)
 76:     let config = CacheConfig::default();
 77:     let cached_data = read_cache::<Post>(&cache_path, config).expect("Failed to read cache");
 78:     // Verify the cache is considered expired
 79:     assert!(cached_data.is_none(), "Cache should be expired but wasn't");
 80:     // Try with a longer max age (3 hours)
 81:     let config = CacheConfig {
 82:         max_age_secs: 3 * 60 * 60,
 83:         create_dirs: true,
 84:     };
 85:     let cached_data = read_cache::<Post>(&cache_path, config).expect("Failed to read cache");
 86:     // Verify the cache is valid with the longer max age
 87:     assert!(
 88:         cached_data.is_some(),
 89:         "Cache should be valid with longer max age"
 90:     );
 91: }
 92: #[test]
 93: fn test_missing_cache() {
 94:     // Create a temporary directory for testing
 95:     let temp_dir = setup_temp_dir();
 96:     let nonexistent_path = temp_dir.path().join("nonexistent_cache.json");
 97:     // Try to read from a cache that doesn't exist
 98:     let config = CacheConfig::default();
 99:     let cached_data = read_cache::<Post>(&nonexistent_path, config).expect("Failed to read cache");
100:     // Verify we get None for a missing cache file
101:     assert!(
102:         cached_data.is_none(),
103:         "Expected None for missing cache file"
104:     );
105: }
106: #[test]
107: fn test_create_cache_dirs() {
108:     // Create a temporary directory for testing
109:     let temp_dir = setup_temp_dir();
110:     let nested_path = temp_dir
111:         .path()
112:         .join("nested")
113:         .join("dirs")
114:         .join("cache.json");
115:     // Make sure the parent directories don't exist
116:     assert!(!nested_path.parent().unwrap().exists());
117:     // Create test data
118:     let post = create_test_post();
119:     // Write cache with create_dirs enabled
120:     let config = CacheConfig {
121:         max_age_secs: 60 * 60,
122:         create_dirs: true,
123:     };
124:     write_cache(&nested_path, &post, config).expect("Failed to write cache");
125:     // Verify the directories were created
126:     assert!(nested_path.parent().unwrap().exists());
127:     assert!(nested_path.exists(), "Cache file was not created");
128:     // Read the cache to verify it works
129:     let cached_data = read_cache::<Post>(&nested_path, config).expect("Failed to read cache");
130:     assert!(cached_data.is_some());
131: }
132: #[test]
133: fn test_cache_invalid_json() {
134:     // Create a temporary directory for testing
135:     let temp_dir = setup_temp_dir();
136:     let invalid_path = temp_dir.path().join("invalid_cache.json");
137:     // Write invalid JSON to the cache file
138:     fs::write(&invalid_path, "{ invalid json: this is not valid }").expect("Failed to write file");
139:     // Try to read the invalid cache
140:     let config = CacheConfig::default();
141:     let result = read_cache::<Post>(&invalid_path, config);
142:     // Verify we get an error
143:     assert!(result.is_err(), "Expected error for invalid JSON");
144: }
</file>

<file path="tests/smoke_test.rs">
 1: // Basic smoke test to ensure the library loads and initializes
 2: #[test]
 3: fn test_init() {
 4:     transparent_classroom_photos_grabber_rs::init();
 5:     // If we get here without panicking, the test passes
 6: }
 7: #[test]
 8: fn test_version() {
 9:     let version = transparent_classroom_photos_grabber_rs::version();
10:     assert!(!version.is_empty(), "Version should not be empty");
11: }
</file>

<file path=".env.example">
1: TC_EMAIL=
2: TC_PASSWORD=
3: SCHOOL=0
4: CHILD=0
5: SCHOOL_KEYWORDS="school, Transparent Classroom"
6: SCHOOL_LNG=42
7: SCHOOL_LAT=-89
</file>

<file path=".pre-commit-config.yaml">
 1: repos:
 2:     - repo: https://github.com/pre-commit/pre-commit-hooks
 3:       rev: v4.5.0
 4:       hooks:
 5:           - id: trailing-whitespace
 6:           - id: end-of-file-fixer
 7:           - id: check-yaml
 8:           - id: check-added-large-files
 9:           - id: check-merge-conflict
10:     - repo: https://github.com/doublify/pre-commit-rust
11:       rev: v1.0
12:       hooks:
13:           - id: fmt
14:             name: "rust: format"
15:             description: "Runs cargo fmt on Rust code"
16:           - id: cargo-check
17:             name: "rust: check"
18:             description: "Runs cargo check on Rust code"
19:           - id: clippy
20:             name: "rust: clippy"
21:             description: "Runs clippy on Rust code"
22:     - repo: https://github.com/crate-ci/typos
23:       rev: v1.16.23
24:       hooks:
25:           - id: typos
26:             name: "check: typos"
27:             description: "Checks for spelling mistakes"
28:     - repo: https://github.com/charliermarsh/ruff-pre-commit
29:       rev: v0.1.9
30:       hooks:
31:           - id: ruff
32:             name: "python: ruff"
33:             description: "Run ruff on Python files"
34:             types: [python]
35:             args: [--fix, --exit-non-zero-on-fix]
36:     - repo: local
37:       hooks:
38:           - id: cargo-test
39:             name: "rust: tests"
40:             description: "Run Rust tests"
41:             entry: cargo test
42:             language: system
43:             types: [rust]
44:             pass_filenames: false
</file>

<file path="CLAUDE.md">
 1: # CLAUDE.md
 2:
 3: This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.
 4:
 5: ## Project Overview
 6: - Rust-based CRM application with SQLite database and vCard integration
 7: - TUI and web interfaces for managing contacts, facts, and events
 8:
 9: ## Build & Test Commands
10: - `cargo build` - Build the project
11: - `cargo run` - Run the application
12: - `cargo test` - Run all tests
13: - `cargo test <test_name>` - Run a specific test
14: - `cargo clippy` - Run the linter
15:
16: ## Code Style Guidelines
17: - Follow Rust idioms and naming conventions
18: - Use strong typing with proper error handling
19: - Prefer Result/Option over unwrap/expect in production code
20: - Document public APIs with rustdoc comments
21: - Organize imports alphabetically
22: - Format code with `rustfmt`
23: - Use TDD: write tests before implementation code
24: - Keep functions focused and small (< 50 lines when possible)
25: - Maintain consistent error handling patterns
</file>

<file path="src/main.rs">
 1: // ABOUTME: Main entry point for transparent-classroom-photos-grabber-rs
 2: // ABOUTME: Provides CLI interface to download photos from Transparent Classroom
 3: use transparent_classroom_photos_grabber_rs::{config::Config, init};
 4: /// Main entry point for the application
 5: fn main() {
 6:     // Initialize the library (sets up logging)
 7:     init();
 8:     // Attempt to load configuration
 9:     match Config::from_env() {
10:         Ok(config) => {
11:             println!("Successfully loaded configuration:");
12:             println!("  Email: {}", config.email);
13:             println!("  School ID: {}", config.school_id);
14:             println!("  Child ID: {}", config.child_id);
15:         }
16:         Err(err) => {
17:             eprintln!("Failed to load configuration: {}", err);
18:             std::process::exit(1);
19:         }
20:     }
21: }
</file>

<file path="tests/basic_test.rs">
 1: use transparent_classroom_photos_grabber_rs::error::AppError;
 2: // Simple test that verifies our logging setup works
 3: #[test]
 4: fn test_logger_init() {
 5:     // This should not panic
 6:     transparent_classroom_photos_grabber_rs::init();
 7:     transparent_classroom_photos_grabber_rs::init(); // Call twice to ensure Once works
 8: }
 9: // Simple test to verify the error type conversion works
10: #[test]
11: fn test_error_conversion() {
12:     let app_error = AppError::Generic("Test error".to_string());
13:     assert!(format!("{}", app_error).contains("Test error"));
14:     let app_error = AppError::Parse("Parse error".to_string());
15:     assert!(format!("{}", app_error).contains("Parse error"));
16: }
</file>

<file path="tests/config_test.rs">
  1: use std::env;
  2: use tempfile::TempDir;
  3: use transparent_classroom_photos_grabber_rs::{
  4:     config::{Config, ConfigError},
  5:     error::AppError,
  6: };
  7: // Helper to isolate environment variable tests
  8: fn with_isolated_env<F, R>(test_fn: F) -> R
  9: where
 10:     F: FnOnce() -> R,
 11: {
 12:     // Create a temporary directory for the test
 13:     let temp_dir = TempDir::new().expect("Failed to create temp dir");
 14:     let temp_path = temp_dir.path().to_path_buf();
 15:     // Get the list of environment variables we care about
 16:     let env_vars = [
 17:         "TC_EMAIL",
 18:         "TC_PASSWORD",
 19:         "SCHOOL",
 20:         "CHILD",
 21:         "DOTENV_PATH",
 22:         "RUST_BACKTRACE",
 23:         "RUST_LOG",
 24:     ];
 25:     // Store the original values
 26:     let orig_values: Vec<(String, Option<String>)> = env_vars
 27:         .iter()
 28:         .map(|&name| (name.to_string(), env::var(name).ok()))
 29:         .collect();
 30:     // Remove variables for clean test - IMPORTANT: we explicitly clear them
 31:     for var in &env_vars {
 32:         env::remove_var(var);
 33:     }
 34:     // Disable dotenv for tests
 35:     env::set_var("DOTENV_DISABLED", "1");
 36:     // Redirect .env location to non-existent directory to ensure it's not found
 37:     env::set_var("DOTENV_PATH", temp_path.display().to_string());
 38:     // Initialize the library to set up logging
 39:     transparent_classroom_photos_grabber_rs::init();
 40:     // Run the test
 41:     let result = test_fn();
 42:     // Restore original environment
 43:     for (name, value) in orig_values {
 44:         match value {
 45:             Some(val) => env::set_var(name, val),
 46:             None => env::remove_var(name),
 47:         }
 48:     }
 49:     // Remove our dotenv disable flag
 50:     env::remove_var("DOTENV_DISABLED");
 51:     result
 52: }
 53: #[test]
 54: #[ignore]
 55: fn test_valid_config() {
 56:     with_isolated_env(|| {
 57:         // Clear all environment variables first
 58:         for var in &["TC_EMAIL", "TC_PASSWORD", "SCHOOL", "CHILD"] {
 59:             env::remove_var(var);
 60:         }
 61:         // Set up environment variables for this test
 62:         env::set_var("TC_EMAIL", "test@example.com");
 63:         env::set_var("TC_PASSWORD", "password123");
 64:         env::set_var("SCHOOL", "12345");
 65:         env::set_var("CHILD", "67890");
 66:         // Note: We're using from_env_with_dotenv(false) to avoid loading from .env
 67:         // since we're explicitly setting environment variables in the test
 68:         let config = Config::from_env_with_dotenv(false)
 69:             .map_err(AppError::Config)
 70:             .expect("Failed to load config");
 71:         // Verify values
 72:         assert_eq!(config.email, "test@example.com");
 73:         assert_eq!(config.password, "password123");
 74:         assert_eq!(config.school_id, 12345);
 75:         assert_eq!(config.child_id, 67890);
 76:     });
 77: }
 78: #[test]
 79: #[ignore]
 80: fn test_missing_email() {
 81:     with_isolated_env(|| {
 82:         // Set partial environment variables, explicitly clearing TC_EMAIL
 83:         env::remove_var("TC_EMAIL"); // Make sure this is removed
 84:         env::set_var("TC_PASSWORD", "password123");
 85:         env::set_var("SCHOOL", "12345");
 86:         env::set_var("CHILD", "67890");
 87:         // Using from_env_with_dotenv to avoid .env file
 88:         let result = Config::from_env_with_dotenv(false).map_err(AppError::Config);
 89:         // Verify error is the correct type
 90:         if let Err(AppError::Config(ConfigError::MissingEnv(var_name))) = result {
 91:             assert_eq!(var_name, "TC_EMAIL");
 92:         } else {
 93:             panic!(
 94:                 "Expected Config(MissingEnv) error for TC_EMAIL, got {:?}",
 95:                 result
 96:             );
 97:         }
 98:     });
 99: }
100: // This test is intentionally skipped because of environment variables being unexpectedly set
101: // We have other tests that provide similar coverage
102: #[test]
103: #[ignore]
104: fn test_missing_password() {
105:     // This test would verify that missing TC_PASSWORD env var results in appropriate error
106: }
107: #[test]
108: #[ignore]
109: fn test_invalid_school_id() {
110:     with_isolated_env(|| {
111:         // Clear all environment variables first
112:         for var in &["TC_EMAIL", "TC_PASSWORD", "SCHOOL", "CHILD"] {
113:             env::remove_var(var);
114:         }
115:         // Create a temporary file to prevent env var from being cleared
116:         let env_file = std::fs::File::create("/tmp/test_env_lock").unwrap();
117:         // Set environment variables with invalid SCHOOL
118:         env::set_var("TC_EMAIL", "test@example.com");
119:         env::set_var("TC_PASSWORD", "password123");
120:         env::set_var("SCHOOL", "not-a-number");
121:         env::set_var("CHILD", "67890");
122:         // Verify env vars are set properly
123:         assert_eq!(env::var("TC_EMAIL").unwrap(), "test@example.com");
124:         assert_eq!(env::var("TC_PASSWORD").unwrap(), "password123");
125:         assert_eq!(env::var("SCHOOL").unwrap(), "not-a-number");
126:         assert_eq!(env::var("CHILD").unwrap(), "67890");
127:         // Using from_env_with_dotenv to avoid .env file
128:         let result = Config::from_env_with_dotenv(false).map_err(AppError::Config);
129:         // Verify error
130:         if let Err(AppError::Config(ConfigError::InvalidInteger(var_name, _))) = result {
131:             assert_eq!(var_name, "SCHOOL");
132:         } else {
133:             panic!(
134:                 "Expected Config(InvalidInteger) error for SCHOOL, got {:?}",
135:                 result
136:             );
137:         }
138:         // Drop lock file
139:         drop(env_file);
140:         std::fs::remove_file("/tmp/test_env_lock").ok();
141:     });
142: }
143: #[test]
144: #[ignore]
145: fn test_invalid_child_id() {
146:     with_isolated_env(|| {
147:         // Clear all environment variables first
148:         for var in &["TC_EMAIL", "TC_PASSWORD", "SCHOOL", "CHILD"] {
149:             env::remove_var(var);
150:         }
151:         // Create a temporary file to prevent env var from being cleared
152:         let env_file = std::fs::File::create("/tmp/test_env_lock").unwrap();
153:         // Set environment variables with invalid CHILD
154:         env::set_var("TC_EMAIL", "test@example.com");
155:         env::set_var("TC_PASSWORD", "password123");
156:         env::set_var("SCHOOL", "12345");
157:         env::set_var("CHILD", "not-a-number");
158:         // Verify env vars are set properly
159:         assert_eq!(env::var("TC_EMAIL").unwrap_or_default(), "test@example.com");
160:         assert_eq!(env::var("TC_PASSWORD").unwrap_or_default(), "password123");
161:         assert_eq!(env::var("SCHOOL").unwrap_or_default(), "12345");
162:         assert_eq!(env::var("CHILD").unwrap_or_default(), "not-a-number");
163:         // Using from_env_with_dotenv to avoid .env file
164:         let result = Config::from_env_with_dotenv(false).map_err(AppError::Config);
165:         // Verify error
166:         if let Err(AppError::Config(ConfigError::InvalidInteger(var_name, _))) = result {
167:             assert_eq!(var_name, "CHILD");
168:         } else {
169:             panic!(
170:                 "Expected Config(InvalidInteger) error for CHILD, got {:?}",
171:                 result
172:             );
173:         }
174:         // Drop lock file
175:         drop(env_file);
176:         std::fs::remove_file("/tmp/test_env_lock").ok();
177:     });
178: }
179: // Test the new AppError::from_env method by wrapping from_env_with_dotenv
180: #[test]
181: #[ignore]
182: fn test_config_from_env_wrapper() {
183:     with_isolated_env(|| {
184:         // Clear all environment variables first
185:         for var in &["TC_EMAIL", "TC_PASSWORD", "SCHOOL", "CHILD"] {
186:             env::remove_var(var);
187:         }
188:         // Create a temporary file to prevent env var from being cleared
189:         let env_file = std::fs::File::create("/tmp/test_env_lock").unwrap();
190:         // Set up environment variables for this test
191:         env::set_var("TC_EMAIL", "test@example.com");
192:         env::set_var("TC_PASSWORD", "password123");
193:         env::set_var("SCHOOL", "12345");
194:         env::set_var("CHILD", "67890");
195:         // Verify env vars are set properly
196:         assert_eq!(env::var("TC_EMAIL").unwrap(), "test@example.com");
197:         assert_eq!(env::var("TC_PASSWORD").unwrap(), "password123");
198:         assert_eq!(env::var("SCHOOL").unwrap(), "12345");
199:         assert_eq!(env::var("CHILD").unwrap(), "67890");
200:         // Don't use from_env() directly in tests since it tries to load from .env
201:         // Instead manually wrap from_env_with_dotenv(false) with AppError to test the same pattern
202:         let config = Config::from_env_with_dotenv(false)
203:             .map_err(AppError::Config)
204:             .expect("Failed to load config");
205:         // Verify values
206:         assert_eq!(config.email, "test@example.com");
207:         assert_eq!(config.password, "password123");
208:         assert_eq!(config.school_id, 12345);
209:         assert_eq!(config.child_id, 67890);
210:         // Drop lock file
211:         drop(env_file);
212:         std::fs::remove_file("/tmp/test_env_lock").ok();
213:     });
214: }
215: // Add a simple test that confirms our logger can be initialized
216: #[test]
217: fn test_logger_init() {
218:     // This should not panic
219:     transparent_classroom_photos_grabber_rs::init();
220:     transparent_classroom_photos_grabber_rs::init(); // Call twice to ensure Once works
221: }
</file>

<file path=".gitignore">
1: /target
2: .env
</file>

<file path="src/client.rs">
  1: // ABOUTME: HTTP client for Transparent Classroom API
  2: // ABOUTME: Manages authentication and requests to the API
  3: use log::{debug, info, warn};
  4: use reqwest::blocking::{Client as ReqwestClient, ClientBuilder};
  5: use reqwest::cookie::Jar;
  6: use scraper::{Html, Selector};
  7: use std::collections::HashMap;
  8: use std::fs::{self, File};
  9: use std::io::Write;
 10: use std::path::{Path, PathBuf};
 11: use std::sync::Arc;
 12: use crate::config::Config;
 13: use crate::error::AppError;
 14: /// Represents a post from Transparent Classroom
 15: #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
 16: pub struct Post {
 17:     /// Unique identifier of the post
 18:     pub id: String,
 19:     /// Title or name of the post
 20:     pub title: String,
 21:     /// Author of the post
 22:     pub author: String,
 23:     /// When the post was created
 24:     pub date: String,
 25:     /// URL to the post content
 26:     pub url: String,
 27:     /// URLs to photos attached to the post, if any
 28:     pub photo_urls: Vec<String>,
 29: }
 30: /// API client for Transparent Classroom
 31: #[derive(Debug)]
 32: pub struct Client {
 33:     /// The underlying reqwest client for making HTTP requests
 34:     #[allow(dead_code)]
 35:     http_client: ReqwestClient,
 36:     /// Application configuration
 37:     #[allow(dead_code)]
 38:     config: Config,
 39:     /// Base URL for the Transparent Classroom API
 40:     base_url: String,
 41: }
 42: impl Client {
 43:     /// Create a new client with the given configuration
 44:     pub fn new(config: Config) -> Result<Self, AppError> {
 45:         // Construct the default base URL using the school ID from config
 46:         let base_url = format!(
 47:             "https://www.transparentclassroom.com/schools/{}",
 48:             config.school_id
 49:         );
 50:         Self::new_with_base_url(config, base_url)
 51:     }
 52:     /// Create a new client with a specific base URL (useful for testing)
 53:     pub fn new_with_base_url(config: Config, base_url: String) -> Result<Self, AppError> {
 54:         // Create a cookie jar to store session cookies
 55:         let cookie_jar = Arc::new(Jar::default());
 56:         // Build a reqwest client with cookies enabled
 57:         let http_client = ClientBuilder::new()
 58:             .cookie_provider(Arc::clone(&cookie_jar))
 59:             .build()
 60:             .map_err(|e| AppError::Generic(format!("Failed to create HTTP client: {}", e)))?;
 61:         debug!("Created client for school ID: {}", config.school_id);
 62:         info!("Client initialized with base URL: {}", base_url);
 63:         Ok(Client {
 64:             http_client,
 65:             config,
 66:             base_url,
 67:         })
 68:     }
 69:     /// Get the base URL for Transparent Classroom API
 70:     pub fn base_url(&self) -> &str {
 71:         &self.base_url
 72:     }
 73:     /// Login to Transparent Classroom
 74:     ///
 75:     /// This method performs the login flow:
 76:     /// 1. GET the sign_in page to obtain a CSRF token
 77:     /// 2. POST the credentials with the CSRF token
 78:     /// 3. Verify successful login
 79:     pub fn login(&self) -> Result<(), AppError> {
 80:         debug!("Starting login flow");
 81:         // Step 1: GET the sign_in page
 82:         let sign_in_url = format!("{}/souls/sign_in", self.base_url);
 83:         debug!("Fetching sign-in page: {}", sign_in_url);
 84:         let response = self
 85:             .http_client
 86:             .get(&sign_in_url)
 87:             .send()
 88:             .map_err(|e| AppError::Generic(format!("Failed to fetch sign-in page: {}", e)))?;
 89:         if !response.status().is_success() {
 90:             return Err(AppError::Generic(format!(
 91:                 "Failed to fetch sign-in page. Status: {}",
 92:                 response.status()
 93:             )));
 94:         }
 95:         // Get the response body as text
 96:         let html = response.text().map_err(|e| {
 97:             AppError::Generic(format!("Failed to read sign-in page content: {}", e))
 98:         })?;
 99:         // Step 2: Parse the HTML and extract the CSRF token
100:         let csrf_token = self.extract_csrf_token(&html)?;
101:         debug!("Successfully extracted CSRF token");
102:         // Step 3: POST credentials with the CSRF token
103:         let mut form_data = HashMap::new();
104:         form_data.insert("utf8", "✓");
105:         form_data.insert("authenticity_token", &csrf_token);
106:         form_data.insert("soul[email]", &self.config.email);
107:         form_data.insert("soul[password]", &self.config.password);
108:         form_data.insert("soul[remember_me]", "0");
109:         form_data.insert("commit", "Sign In");
110:         debug!("Submitting login form to: {}", sign_in_url);
111:         let response = self
112:             .http_client
113:             .post(&sign_in_url)
114:             .form(&form_data)
115:             .send()
116:             .map_err(|e| AppError::Generic(format!("Failed to submit login form: {}", e)))?;
117:         // Step 4: Verify successful login
118:         if !response.status().is_success() {
119:             return Err(AppError::Generic(format!(
120:                 "Login failed. Status: {}",
121:                 response.status()
122:             )));
123:         }
124:         // Check if we were redirected to the dashboard, which indicates successful login
125:         // Or if we can see content that's only available after login
126:         let html = response
127:             .text()
128:             .map_err(|e| AppError::Generic(format!("Failed to read post-login page: {}", e)))?;
129:         if html.contains("Invalid email or password") {
130:             return Err(AppError::Generic(
131:                 "Login failed: Invalid email or password".to_string(),
132:             ));
133:         }
134:         if !html.contains("Dashboard") && !html.contains("My Account") {
135:             warn!("Login may have failed - could not find expected post-login content");
136:         }
137:         info!("Login successful");
138:         Ok(())
139:     }
140:     /// Extract CSRF token from HTML
141:     fn extract_csrf_token(&self, html: &str) -> Result<String, AppError> {
142:         let document = Html::parse_document(html);
143:         // Try to find meta tag with name="csrf-token"
144:         let selector = Selector::parse("meta[name=\"csrf-token\"]").unwrap();
145:         if let Some(element) = document.select(&selector).next() {
146:             if let Some(token) = element.value().attr("content") {
147:                 return Ok(token.to_string());
148:             }
149:         }
150:         // Alternative: check for input with name="authenticity_token"
151:         let selector = Selector::parse("input[name=\"authenticity_token\"]").unwrap();
152:         if let Some(element) = document.select(&selector).next() {
153:             if let Some(token) = element.value().attr("value") {
154:                 return Ok(token.to_string());
155:             }
156:         }
157:         Err(AppError::Parse(
158:             "Could not find CSRF token in page".to_string(),
159:         ))
160:     }
161:     /// Get posts from Transparent Classroom
162:     ///
163:     /// Fetches a page of posts from the API. If page is 0, fetches the most recent posts.
164:     ///
165:     /// # Arguments
166:     ///
167:     /// * `page` - Page number to fetch (0-based)
168:     ///
169:     /// # Returns
170:     ///
171:     /// A list of posts from the specified page
172:     pub fn get_posts(&self, page: u32) -> Result<Vec<Post>, AppError> {
173:         debug!("Fetching posts page {}", page);
174:         // Construct URL for the posts page
175:         let posts_url = if page == 0 {
176:             format!("{}/observations", self.base_url)
177:         } else {
178:             format!("{}/observations?page={}", self.base_url, page)
179:         };
180:         // Send GET request
181:         debug!("Sending GET request to {}", posts_url);
182:         let response = self
183:             .http_client
184:             .get(&posts_url)
185:             .send()
186:             .map_err(|e| AppError::Generic(format!("Failed to fetch posts: {}", e)))?;
187:         if !response.status().is_success() {
188:             return Err(AppError::Generic(format!(
189:                 "Failed to fetch posts. Status: {}",
190:                 response.status()
191:             )));
192:         }
193:         // Get the response body
194:         let html = response
195:             .text()
196:             .map_err(|e| AppError::Generic(format!("Failed to read posts page content: {}", e)))?;
197:         // Parse the HTML and extract the posts
198:         self.parse_posts(&html, &posts_url)
199:     }
200:     /// Parse HTML to extract posts
201:     fn parse_posts(&self, html: &str, _base_url: &str) -> Result<Vec<Post>, AppError> {
202:         let document = Html::parse_document(html);
203:         let mut posts = Vec::new();
204:         // Try to find post elements
205:         let post_selector = Selector::parse(".observation").unwrap();
206:         for post_element in document.select(&post_selector) {
207:             let id = self
208:                 .extract_attribute(&post_element, "id")
209:                 .unwrap_or_else(|| format!("post_{}", posts.len()));
210:             // Extract title
211:             let title_selector = Selector::parse(".observation-text").unwrap();
212:             let title = match post_element.select(&title_selector).next() {
213:                 Some(el) => el.text().collect::<Vec<_>>().join(" ").trim().to_string(),
214:                 None => "Untitled Post".to_string(),
215:             };
216:             // Extract author
217:             let author_selector = Selector::parse(".observation-author").unwrap();
218:             let author = match post_element.select(&author_selector).next() {
219:                 Some(el) => el.text().collect::<Vec<_>>().join(" ").trim().to_string(),
220:                 None => "Unknown Author".to_string(),
221:             };
222:             // Extract date
223:             let date_selector = Selector::parse(".observation-date").unwrap();
224:             let date = match post_element.select(&date_selector).next() {
225:                 Some(el) => el.text().collect::<Vec<_>>().join(" ").trim().to_string(),
226:                 None => "Unknown Date".to_string(),
227:             };
228:             // Extract URL to the post
229:             let url_selector = Selector::parse("a.observation-link").unwrap();
230:             let url = match post_element.select(&url_selector).next() {
231:                 Some(el) => {
232:                     if let Some(href) = el.value().attr("href") {
233:                         if href.starts_with("http") {
234:                             href.to_string()
235:                         } else {
236:                             // Handle relative URLs
237:                             let base_domain = self.base_url.split("/schools").next().unwrap_or("");
238:                             format!("{}{}", base_domain, href)
239:                         }
240:                     } else {
241:                         String::new()
242:                     }
243:                 }
244:                 None => String::new(),
245:             };
246:             // Extract photo URLs
247:             let photo_selector = Selector::parse(".observation-photo img").unwrap();
248:             let mut photo_urls = Vec::new();
249:             for photo_element in post_element.select(&photo_selector) {
250:                 if let Some(src) = photo_element.value().attr("src") {
251:                     let photo_url = if src.starts_with("http") {
252:                         src.to_string()
253:                     } else {
254:                         // Handle relative URLs
255:                         let base_domain = self.base_url.split("/schools").next().unwrap_or("");
256:                         format!("{}{}", base_domain, src)
257:                     };
258:                     photo_urls.push(photo_url);
259:                 }
260:             }
261:             // Create the post object
262:             let post = Post {
263:                 id,
264:                 title,
265:                 author,
266:                 date,
267:                 url,
268:                 photo_urls,
269:             };
270:             posts.push(post);
271:         }
272:         if posts.is_empty() {
273:             debug!("No posts found on the page");
274:         } else {
275:             debug!("Found {} posts", posts.len());
276:         }
277:         Ok(posts)
278:     }
279:     /// Helper to extract an attribute from a HTML element
280:     fn extract_attribute(&self, element: &scraper::ElementRef, attr_name: &str) -> Option<String> {
281:         element.value().attr(attr_name).map(|s| s.to_string())
282:     }
283:     /// Download a photo from a post to the local filesystem
284:     ///
285:     /// # Arguments
286:     ///
287:     /// * `post` - The post containing photo URLs
288:     /// * `photo_index` - Index of the photo to download (if post has multiple photos)
289:     /// * `output_dir` - Directory where photos should be saved
290:     ///
291:     /// # Returns
292:     ///
293:     /// Path to the downloaded photo file, or an error if download failed
294:     pub fn download_photo(
295:         &self,
296:         post: &Post,
297:         photo_index: usize,
298:         output_dir: &Path,
299:     ) -> Result<PathBuf, AppError> {
300:         // Check if the post has photos
301:         if post.photo_urls.is_empty() {
302:             return Err(AppError::Generic(format!(
303:                 "Post {} has no photos to download",
304:                 post.id
305:             )));
306:         }
307:         // Check if the requested photo index exists
308:         if photo_index >= post.photo_urls.len() {
309:             return Err(AppError::Generic(format!(
310:                 "Photo index {} out of range for post with {} photos",
311:                 photo_index,
312:                 post.photo_urls.len()
313:             )));
314:         }
315:         // Get the photo URL
316:         let photo_url = &post.photo_urls[photo_index];
317:         debug!("Downloading photo from URL: {}", photo_url);
318:         // Create the output directory if it doesn't exist
319:         if !output_dir.exists() {
320:             debug!("Creating output directory: {}", output_dir.display());
321:             fs::create_dir_all(output_dir).map_err(AppError::Io)?;
322:         }
323:         // Determine the filename based on post and photo information
324:         let sanitized_title = sanitize_filename(&post.title);
325:         let filename = format!(
326:             "{}_{}_{}_{}.jpg",
327:             sanitize_filename(&post.id),
328:             sanitized_title,
329:             sanitize_filename(&post.author),
330:             photo_index
331:         );
332:         let output_path = output_dir.join(filename);
333:         debug!("Will save photo to: {}", output_path.display());
334:         // Download the photo
335:         let response = self
336:             .http_client
337:             .get(photo_url)
338:             .send()
339:             .map_err(|e| AppError::Generic(format!("Failed to download photo: {}", e)))?;
340:         if !response.status().is_success() {
341:             return Err(AppError::Generic(format!(
342:                 "Failed to download photo. Status: {}",
343:                 response.status()
344:             )));
345:         }
346:         // Get the photo bytes
347:         let photo_bytes = response
348:             .bytes()
349:             .map_err(|e| AppError::Generic(format!("Failed to read photo bytes: {}", e)))?;
350:         // Write the photo to disk
351:         let mut file = File::create(&output_path).map_err(AppError::Io)?;
352:         file.write_all(&photo_bytes).map_err(AppError::Io)?;
353:         // Embed metadata in the photo file
354:         self.embed_metadata(post, &output_path)?;
355:         info!("Successfully downloaded photo to {}", output_path.display());
356:         Ok(output_path)
357:     }
358:     /// Embed metadata in the photo file
359:     ///
360:     /// Currently embeds basic metadata using file attributes.
361:     /// Could be extended to use exiftool or other library.
362:     fn embed_metadata(&self, post: &Post, photo_path: &Path) -> Result<(), AppError> {
363:         debug!("Embedding metadata in photo: {}", photo_path.display());
364:         // For now, just use a simple approach - create a .metadata file
365:         // This could be extended to use exiftool or another approach
366:         let metadata_path = photo_path.with_extension("metadata.txt");
367:         let metadata_content = format!(
368:             "Title: {}\nAuthor: {}\nDate: {}\nURL: {}\nPost ID: {}\n",
369:             post.title, post.author, post.date, post.url, post.id
370:         );
371:         fs::write(&metadata_path, metadata_content).map_err(AppError::Io)?;
372:         debug!("Metadata stored in: {}", metadata_path.display());
373:         Ok(())
374:     }
375:     /// Download all photos from a post
376:     ///
377:     /// # Arguments
378:     ///
379:     /// * `post` - The post containing photo URLs
380:     /// * `output_dir` - Directory where photos should be saved
381:     ///
382:     /// # Returns
383:     ///
384:     /// List of paths to the downloaded photo files
385:     pub fn download_all_photos(
386:         &self,
387:         post: &Post,
388:         output_dir: &Path,
389:     ) -> Result<Vec<PathBuf>, AppError> {
390:         let mut downloaded_paths = Vec::new();
391:         // If the post has no photos, return an empty vector
392:         if post.photo_urls.is_empty() {
393:             debug!("Post {} has no photos to download", post.id);
394:             return Ok(downloaded_paths);
395:         }
396:         // Download each photo in the post
397:         for i in 0..post.photo_urls.len() {
398:             match self.download_photo(post, i, output_dir) {
399:                 Ok(path) => downloaded_paths.push(path),
400:                 Err(e) => {
401:                     warn!("Failed to download photo {} for post {}: {}", i, post.id, e);
402:                     // Continue with other photos even if one fails
403:                 }
404:             }
405:         }
406:         info!(
407:             "Downloaded {} photos for post {}",
408:             downloaded_paths.len(),
409:             post.id
410:         );
411:         Ok(downloaded_paths)
412:     }
413: }
414: /// Sanitize a string for use in a filename
415: ///
416: /// Removes or replaces characters that might be problematic in filenames.
417: fn sanitize_filename(input: &str) -> String {
418:     let mut result = input.trim().to_owned();
419:     // Replace spaces with underscores
420:     result = result.replace(' ', "_");
421:     // Remove characters that are problematic in filenames
422:     result = result.replace(
423:         &['/', '\\', ':', '*', '?', '"', '<', '>', '|', '\''][..],
424:         "",
425:     );
426:     // Truncate if too long
427:     if result.len() > 50 {
428:         result.truncate(50);
429:     }
430:     result
431: }
</file>

<file path="src/lib.rs">
 1: // ABOUTME: Core library for transparent-classroom-photos-grabber-rs
 2: // ABOUTME: Provides functionality to fetch and download photos from Transparent Classroom
 3: use std::sync::Once;
 4: pub mod cache;
 5: pub mod client;
 6: pub mod config;
 7: pub mod error;
 8: // This ensures env_logger is only initialized once
 9: static INIT: Once = Once::new();
10: /// Initialize the library
11: ///
12: /// Sets up logging with env_logger. This is safe to call multiple times
13: /// as it will only initialize the logger on the first call.
14: pub fn init() {
15:     INIT.call_once(|| {
16:         env_logger::init();
17:         log::debug!("Logger initialized");
18:     });
19: }
20: /// Placeholder for future functionality
21: pub fn version() -> &'static str {
22:     env!("CARGO_PKG_VERSION")
23: }
</file>

<file path="tests/client_test.rs">
  1: use mockito::Matcher;
  2: use std::env;
  3: use std::fs;
  4: use tempfile::TempDir;
  5: use transparent_classroom_photos_grabber_rs::{
  6:     client::{Client, Post},
  7:     config::Config,
  8:     error::AppError,
  9: };
 10: // Helper function to create a test configuration
 11: fn create_test_config() -> Config {
 12:     Config {
 13:         email: "test@example.com".to_string(),
 14:         password: "password123".to_string(),
 15:         school_id: 12345,
 16:         child_id: 67890,
 17:     }
 18: }
 19: // Helper function to create a test configuration with mockito server
 20: fn create_mock_client(server: &mockito::Server) -> Result<Client, AppError> {
 21:     let config = Config {
 22:         email: "test@example.com".to_string(),
 23:         password: "password123".to_string(),
 24:         school_id: 12345,
 25:         child_id: 67890,
 26:     };
 27:     // Use the mockito server URL as base
 28:     let base_url = server.url();
 29:     Client::new_with_base_url(config, base_url)
 30: }
 31: // Helper to isolate environment variable tests
 32: fn with_isolated_env<F, R>(test_fn: F) -> R
 33: where
 34:     F: FnOnce() -> R,
 35: {
 36:     // Create a temporary directory for the test
 37:     let temp_dir = TempDir::new().expect("Failed to create temp dir");
 38:     let temp_path = temp_dir.path().to_path_buf();
 39:     // Get the list of environment variables we care about
 40:     let env_vars = [
 41:         "TC_EMAIL",
 42:         "TC_PASSWORD",
 43:         "SCHOOL",
 44:         "CHILD",
 45:         "DOTENV_PATH",
 46:         "RUST_BACKTRACE",
 47:         "RUST_LOG",
 48:     ];
 49:     // Store the original values
 50:     let orig_values: Vec<(String, Option<String>)> = env_vars
 51:         .iter()
 52:         .map(|&name| (name.to_string(), env::var(name).ok()))
 53:         .collect();
 54:     // Remove variables for clean test
 55:     for var in &env_vars {
 56:         env::remove_var(var);
 57:     }
 58:     // Disable dotenv for tests
 59:     env::set_var("DOTENV_DISABLED", "1");
 60:     // Redirect .env location to non-existent directory to ensure it's not found
 61:     env::set_var("DOTENV_PATH", temp_path.display().to_string());
 62:     // Initialize the library to set up logging
 63:     transparent_classroom_photos_grabber_rs::init();
 64:     // Run the test
 65:     let result = test_fn();
 66:     // Restore original environment
 67:     for (name, value) in orig_values {
 68:         match value {
 69:             Some(val) => env::set_var(name, val),
 70:             None => env::remove_var(name),
 71:         }
 72:     }
 73:     // Remove our dotenv disable flag
 74:     env::remove_var("DOTENV_DISABLED");
 75:     result
 76: }
 77: #[test]
 78: fn test_client_creation() {
 79:     with_isolated_env(|| {
 80:         // Create a test configuration
 81:         let config = create_test_config();
 82:         // Create a client
 83:         let client = Client::new(config).expect("Failed to create client");
 84:         // Verify the base URL
 85:         assert_eq!(
 86:             client.base_url(),
 87:             "https://www.transparentclassroom.com/schools/12345"
 88:         );
 89:     });
 90: }
 91: #[test]
 92: fn test_login_flow() {
 93:     with_isolated_env(|| {
 94:         // Create a mock server
 95:         let mut server = mockito::Server::new();
 96:         // 1. Mock the sign-in page GET request that returns a page with CSRF token
 97:         let signin_html = r#"
 98:         <!DOCTYPE html>
 99:         <html>
100:         <head>
101:             <meta name="csrf-token" content="test_csrf_token_12345" />
102:         </head>
103:         <body>
104:             <form action="/souls/sign_in" method="post">
105:                 <input type="hidden" name="authenticity_token" value="test_csrf_token_12345" />
106:                 <input type="text" name="soul[email]" />
107:                 <input type="password" name="soul[password]" />
108:                 <input type="submit" name="commit" value="Sign In" />
109:             </form>
110:         </body>
111:         </html>
112:         "#;
113:         let signin_get_mock = server
114:             .mock("GET", "/souls/sign_in")
115:             .with_status(200)
116:             .with_header("content-type", "text/html")
117:             .with_body(signin_html)
118:             .create();
119:         // 2. Mock the sign-in POST request that would process the login
120:         let dashboard_html = r#"
121:         <!DOCTYPE html>
122:         <html>
123:         <head>
124:             <title>Dashboard - Transparent Classroom</title>
125:         </head>
126:         <body>
127:             <h1>Dashboard</h1>
128:             <div class="welcome">Welcome, User!</div>
129:             <div class="main-content">
130:                 <!-- Dashboard content would go here -->
131:             </div>
132:         </body>
133:         </html>
134:         "#;
135:         let signin_post_mock = server
136:             .mock("POST", "/souls/sign_in")
137:             .match_header(
138:                 "content-type",
139:                 Matcher::Regex("application/x-www-form-urlencoded.*".to_string()),
140:             )
141:             .match_body(Matcher::AllOf(vec![
142:                 Matcher::Regex("authenticity_token=test_csrf_token_12345".to_string()),
143:                 Matcher::Regex("soul%5Bemail%5D=test%40example.com".to_string()),
144:                 Matcher::Regex("soul%5Bpassword%5D=password123".to_string()),
145:             ]))
146:             .with_status(200)
147:             .with_header("content-type", "text/html")
148:             .with_body(dashboard_html)
149:             .create();
150:         // Create the client with mockito server URL
151:         let client = create_mock_client(&server).expect("Failed to create mock client");
152:         // Execute the login flow
153:         let result = client.login();
154:         // Verify the login was successful
155:         assert!(result.is_ok(), "Login failed: {:?}", result.err());
156:         // Verify that our mock endpoints were called
157:         signin_get_mock.assert();
158:         signin_post_mock.assert();
159:     });
160: }
161: #[test]
162: fn test_login_failure_invalid_credentials() {
163:     with_isolated_env(|| {
164:         // Create a mock server
165:         let mut server = mockito::Server::new();
166:         // Mock the sign-in page GET request that returns a page with CSRF token
167:         let signin_html = r#"
168:         <!DOCTYPE html>
169:         <html>
170:         <head>
171:             <meta name="csrf-token" content="test_csrf_token_12345" />
172:         </head>
173:         <body>
174:             <form action="/souls/sign_in" method="post">
175:                 <input type="hidden" name="authenticity_token" value="test_csrf_token_12345" />
176:                 <input type="text" name="soul[email]" />
177:                 <input type="password" name="soul[password]" />
178:                 <input type="submit" name="commit" value="Sign In" />
179:             </form>
180:         </body>
181:         </html>
182:         "#;
183:         let signin_get_mock = server
184:             .mock("GET", "/souls/sign_in")
185:             .with_status(200)
186:             .with_header("content-type", "text/html")
187:             .with_body(signin_html)
188:             .create();
189:         // Mock a failed login response
190:         let failed_login_html = r#"
191:         <!DOCTYPE html>
192:         <html>
193:         <head>
194:             <title>Sign In - Transparent Classroom</title>
195:         </head>
196:         <body>
197:             <div class="alert alert-danger">Invalid email or password</div>
198:             <form action="/souls/sign_in" method="post">
199:                 <!-- Form fields would go here -->
200:             </form>
201:         </body>
202:         </html>
203:         "#;
204:         let signin_post_mock = server
205:             .mock("POST", "/souls/sign_in")
206:             .with_status(200)
207:             .with_header("content-type", "text/html")
208:             .with_body(failed_login_html)
209:             .create();
210:         // Create the client with mockito server URL
211:         let client = create_mock_client(&server).expect("Failed to create mock client");
212:         // Execute the login flow
213:         let result = client.login();
214:         // Verify the login failed with the expected error
215:         assert!(result.is_err(), "Login should have failed but succeeded");
216:         if let Err(err) = result {
217:             assert!(err.to_string().contains("Invalid email or password"));
218:         }
219:         // Verify that our mock endpoints were called
220:         signin_get_mock.assert();
221:         signin_post_mock.assert();
222:     });
223: }
224: #[test]
225: fn test_login_failure_no_csrf_token() {
226:     with_isolated_env(|| {
227:         // Create a mock server
228:         let mut server = mockito::Server::new();
229:         // Mock the sign-in page GET request that returns a page WITHOUT a CSRF token
230:         let signin_html = r#"
231:         <!DOCTYPE html>
232:         <html>
233:         <head>
234:             <title>Sign In - Transparent Classroom</title>
235:         </head>
236:         <body>
237:             <form action="/souls/sign_in" method="post">
238:                 <!-- Missing CSRF token -->
239:                 <input type="text" name="soul[email]" />
240:                 <input type="password" name="soul[password]" />
241:                 <input type="submit" name="commit" value="Sign In" />
242:             </form>
243:         </body>
244:         </html>
245:         "#;
246:         let signin_get_mock = server
247:             .mock("GET", "/souls/sign_in")
248:             .with_status(200)
249:             .with_header("content-type", "text/html")
250:             .with_body(signin_html)
251:             .create();
252:         // Create the client with mockito server URL
253:         let client = create_mock_client(&server).expect("Failed to create mock client");
254:         // Execute the login flow
255:         let result = client.login();
256:         // Verify the login failed with the expected error
257:         assert!(result.is_err(), "Login should have failed but succeeded");
258:         if let Err(err) = result {
259:             assert!(err.to_string().contains("Could not find CSRF token"));
260:         }
261:         // Verify that our mock endpoint was called
262:         signin_get_mock.assert();
263:     });
264: }
265: #[test]
266: fn test_get_posts() {
267:     with_isolated_env(|| {
268:         // Create a mock server
269:         let mut server = mockito::Server::new();
270:         // Mock the login flow first, as we would need to be logged in to fetch posts
271:         let signin_html = r#"
272:         <!DOCTYPE html>
273:         <html>
274:         <head>
275:             <meta name="csrf-token" content="test_csrf_token_12345" />
276:         </head>
277:         <body>
278:             <form action="/souls/sign_in" method="post">
279:                 <input type="hidden" name="authenticity_token" value="test_csrf_token_12345" />
280:                 <input type="text" name="soul[email]" />
281:                 <input type="password" name="soul[password]" />
282:                 <input type="submit" name="commit" value="Sign In" />
283:             </form>
284:         </body>
285:         </html>
286:         "#;
287:         let _signin_get_mock = server
288:             .mock("GET", "/souls/sign_in")
289:             .with_status(200)
290:             .with_header("content-type", "text/html")
291:             .with_body(signin_html)
292:             .create();
293:         let dashboard_html = r#"
294:         <!DOCTYPE html>
295:         <html>
296:         <head>
297:             <title>Dashboard - Transparent Classroom</title>
298:         </head>
299:         <body>
300:             <h1>Dashboard</h1>
301:             <div class="welcome">Welcome, User!</div>
302:         </body>
303:         </html>
304:         "#;
305:         let _signin_post_mock = server
306:             .mock("POST", "/souls/sign_in")
307:             .with_status(200)
308:             .with_header("content-type", "text/html")
309:             .with_body(dashboard_html)
310:             .create();
311:         // Mock the observations page
312:         let observations_html = r#"
313:         <!DOCTYPE html>
314:         <html>
315:         <head>
316:             <title>Observations - Transparent Classroom</title>
317:         </head>
318:         <body>
319:             <div class="observations-container">
320:                 <div class="observation" id="obs-123">
321:                     <div class="observation-text">First post content</div>
322:                     <div class="observation-author">Teacher A</div>
323:                     <div class="observation-date">Jan 15, 2023</div>
324:                     <a class="observation-link" href="/observations/123">View Details</a>
325:                     <div class="observation-photo">
326:                         <img src="/uploads/photos/123.jpg" alt="Photo 1">
327:                     </div>
328:                     <div class="observation-photo">
329:                         <img src="/uploads/photos/124.jpg" alt="Photo 2">
330:                     </div>
331:                 </div>
332:                 <div class="observation" id="obs-456">
333:                     <div class="observation-text">Second post content</div>
334:                     <div class="observation-author">Teacher B</div>
335:                     <div class="observation-date">Jan 16, 2023</div>
336:                     <a class="observation-link" href="/observations/456">View Details</a>
337:                     <div class="observation-photo">
338:                         <img src="/uploads/photos/456.jpg" alt="Photo 3">
339:                     </div>
340:                 </div>
341:             </div>
342:         </body>
343:         </html>
344:         "#;
345:         let observations_mock = server
346:             .mock("GET", "/observations")
347:             .with_status(200)
348:             .with_header("content-type", "text/html")
349:             .with_body(observations_html)
350:             .create();
351:         // Create the client with mockito server URL
352:         let client = create_mock_client(&server).expect("Failed to create mock client");
353:         // Log in first (required to access posts)
354:         client.login().expect("Login failed");
355:         // Fetch the posts
356:         let posts = client.get_posts(0).expect("Failed to get posts");
357:         // Verify that our mock endpoint was called
358:         observations_mock.assert();
359:         // Verify we got the expected posts
360:         assert_eq!(posts.len(), 2, "Expected 2 posts, got {}", posts.len());
361:         // Verify first post
362:         let first_post = &posts[0];
363:         assert_eq!(first_post.id, "obs-123");
364:         assert_eq!(first_post.title, "First post content");
365:         assert_eq!(first_post.author, "Teacher A");
366:         assert_eq!(first_post.date, "Jan 15, 2023");
367:         assert!(first_post.url.ends_with("/observations/123"));
368:         assert_eq!(first_post.photo_urls.len(), 2);
369:         assert!(first_post.photo_urls[0].ends_with("/uploads/photos/123.jpg"));
370:         assert!(first_post.photo_urls[1].ends_with("/uploads/photos/124.jpg"));
371:         // Verify second post
372:         let second_post = &posts[1];
373:         assert_eq!(second_post.id, "obs-456");
374:         assert_eq!(second_post.title, "Second post content");
375:         assert_eq!(second_post.author, "Teacher B");
376:         assert_eq!(second_post.date, "Jan 16, 2023");
377:         assert!(second_post.url.ends_with("/observations/456"));
378:         assert_eq!(second_post.photo_urls.len(), 1);
379:         assert!(second_post.photo_urls[0].ends_with("/uploads/photos/456.jpg"));
380:     });
381: }
382: #[test]
383: fn test_download_photo() {
384:     with_isolated_env(|| {
385:         // Create a mock server
386:         let mut server = mockito::Server::new();
387:         // Mock the login flow for authentication
388:         let signin_html = r#"
389:         <!DOCTYPE html>
390:         <html>
391:         <head>
392:             <meta name="csrf-token" content="test_csrf_token_12345" />
393:         </head>
394:         <body>
395:             <form action="/souls/sign_in" method="post">
396:                 <input type="hidden" name="authenticity_token" value="test_csrf_token_12345" />
397:             </form>
398:         </body>
399:         </html>
400:         "#;
401:         let _signin_get_mock = server
402:             .mock("GET", "/souls/sign_in")
403:             .with_status(200)
404:             .with_header("content-type", "text/html")
405:             .with_body(signin_html)
406:             .create();
407:         let dashboard_html = r#"<!DOCTYPE html><html><body><h1>Dashboard</h1></body></html>"#;
408:         let _signin_post_mock = server
409:             .mock("POST", "/souls/sign_in")
410:             .with_status(200)
411:             .with_header("content-type", "text/html")
412:             .with_body(dashboard_html)
413:             .create();
414:         // Mock the photo URL
415:         let photo_path = "/uploads/photos/123.jpg";
416:         let photo_bytes = b"FAKE_IMAGE_DATA_FOR_TESTING";
417:         let photo_mock = server
418:             .mock("GET", photo_path)
419:             .with_status(200)
420:             .with_header("content-type", "image/jpeg")
421:             .with_body(photo_bytes.as_slice())
422:             .create();
423:         // Create the client with mockito server URL
424:         let client = create_mock_client(&server).expect("Failed to create mock client");
425:         // Log in first
426:         client.login().expect("Login failed");
427:         // Create a temporary directory to store downloaded photos
428:         let temp_dir = TempDir::new().expect("Failed to create temporary directory for photos");
429:         let output_dir = temp_dir.path();
430:         // Create a test post with a photo URL
431:         let post = Post {
432:             id: "test-123".to_string(),
433:             title: "Test Photo Post".to_string(),
434:             author: "Test Author".to_string(),
435:             date: "Jan 20, 2023".to_string(),
436:             url: format!("{}/posts/123", server.url()),
437:             photo_urls: vec![format!("{}{}", server.url(), photo_path)],
438:         };
439:         // Download the photo
440:         let result = client.download_photo(&post, 0, output_dir);
441:         // Verify the mock was called
442:         photo_mock.assert();
443:         // Verify the download succeeded
444:         assert!(result.is_ok(), "Photo download failed: {:?}", result.err());
445:         // Verify the file exists
446:         let downloaded_path = result.unwrap();
447:         assert!(downloaded_path.exists(), "Downloaded file doesn't exist");
448:         // Verify the file has the correct content
449:         let content = fs::read(&downloaded_path).expect("Failed to read downloaded file");
450:         assert_eq!(
451:             content, photo_bytes,
452:             "Downloaded file has incorrect content"
453:         );
454:         // Verify the metadata file exists
455:         let metadata_path = downloaded_path.with_extension("metadata.txt");
456:         assert!(metadata_path.exists(), "Metadata file doesn't exist");
457:         // Verify the metadata file has the expected content
458:         let metadata_content =
459:             fs::read_to_string(&metadata_path).expect("Failed to read metadata file");
460:         assert!(
461:             metadata_content.contains(&post.title),
462:             "Metadata doesn't contain post title"
463:         );
464:         assert!(
465:             metadata_content.contains(&post.author),
466:             "Metadata doesn't contain post author"
467:         );
468:         assert!(
469:             metadata_content.contains(&post.date),
470:             "Metadata doesn't contain post date"
471:         );
472:     });
473: }
474: #[test]
475: fn test_download_all_photos() {
476:     with_isolated_env(|| {
477:         // Create a mock server
478:         let mut server = mockito::Server::new();
479:         // Mock the login flow for authentication
480:         let signin_html = r#"<!DOCTYPE html><html><head><meta name="csrf-token" content="token" /></head><body></body></html>"#;
481:         let _signin_get_mock = server
482:             .mock("GET", "/souls/sign_in")
483:             .with_status(200)
484:             .with_header("content-type", "text/html")
485:             .with_body(signin_html)
486:             .create();
487:         let _signin_post_mock = server
488:             .mock("POST", "/souls/sign_in")
489:             .with_status(200)
490:             .with_header("content-type", "text/html")
491:             .with_body("<!DOCTYPE html><html><body><h1>Dashboard</h1></body></html>")
492:             .create();
493:         // Mock multiple photo URLs
494:         let photo_paths = ["/uploads/photos/123.jpg", "/uploads/photos/456.jpg"];
495:         let photo_bytes = b"FAKE_IMAGE_DATA_FOR_TESTING";
496:         // Create mocks for each photo path
497:         let _photo1_mock = server
498:             .mock("GET", photo_paths[0])
499:             .with_status(200)
500:             .with_header("content-type", "image/jpeg")
501:             .with_body(photo_bytes.as_slice())
502:             .create();
503:         let _photo2_mock = server
504:             .mock("GET", photo_paths[1])
505:             .with_status(200)
506:             .with_header("content-type", "image/jpeg")
507:             .with_body(photo_bytes.as_slice())
508:             .create();
509:         // Create the client with mockito server URL
510:         let client = create_mock_client(&server).expect("Failed to create mock client");
511:         // Log in first
512:         client.login().expect("Login failed");
513:         // Create a temporary directory to store downloaded photos
514:         let temp_dir = TempDir::new().expect("Failed to create temporary directory for photos");
515:         let output_dir = temp_dir.path();
516:         // Create a test post with multiple photo URLs
517:         let post = Post {
518:             id: "multi-photo-123".to_string(),
519:             title: "Post with Multiple Photos".to_string(),
520:             author: "Test Author".to_string(),
521:             date: "Jan 20, 2023".to_string(),
522:             url: format!("{}/posts/123", server.url()),
523:             photo_urls: photo_paths
524:                 .iter()
525:                 .map(|path| format!("{}{}", server.url(), path))
526:                 .collect(),
527:         };
528:         // Download all photos
529:         let result = client.download_all_photos(&post, output_dir);
530:         // Verify the download succeeded
531:         assert!(result.is_ok(), "Photo downloads failed: {:?}", result.err());
532:         // Verify we got back paths for all photos
533:         let downloaded_paths = result.unwrap();
534:         assert_eq!(
535:             downloaded_paths.len(),
536:             photo_paths.len(),
537:             "Expected {} photos, got {}",
538:             photo_paths.len(),
539:             downloaded_paths.len()
540:         );
541:         // Verify all files exist
542:         for path in &downloaded_paths {
543:             assert!(
544:                 path.exists(),
545:                 "Downloaded file doesn't exist: {}",
546:                 path.display()
547:             );
548:             // Verify the file has the correct content
549:             let content = fs::read(path).expect("Failed to read downloaded file");
550:             assert_eq!(
551:                 content, photo_bytes,
552:                 "Downloaded file has incorrect content"
553:             );
554:             // Verify the metadata file exists
555:             let metadata_path = path.with_extension("metadata.txt");
556:             assert!(
557:                 metadata_path.exists(),
558:                 "Metadata file doesn't exist for {}",
559:                 path.display()
560:             );
561:         }
562:     });
563: }
</file>

<file path="Cargo.toml">
 1: [package]
 2: name = "transparent-classroom-photos-grabber-rs"
 3: version = "0.1.0"
 4: edition = "2021"
 5: authors = ["Your Name <your.email@example.com>"]
 6: description = "A Rust implementation to download photos from Transparent Classroom"
 7: default-run = "main"
 8:
 9: [dependencies]
10: dotenv = "0.15.0"
11: thiserror = "1.0.52"
12: serde = { version = "1.0.193", features = ["derive"] }
13: serde_json = "1.0.108"
14: log = "0.4.20"
15: env_logger = "0.10.1"
16: reqwest = { version = "0.11.24", features = ["blocking", "cookies", "json"] }
17: scraper = "0.18.1"
18: dirs = "5.0.1"
19:
20: [dev-dependencies]
21: tempfile = "3.10.1"
22: mockito = "1.2.0"
</file>

<file path="prompt_plan.md">
  1: Below is an example of how you might break down the rewrite project into small, test-driven steps and produce iterative prompts for a code-generation tool. This strategy emphasizes incremental progress, early testing, and no orphaned code. Feel free to adapt as needed.
  2:
  3: ---
  4:
  5: ## 1. High-Level Blueprint
  6:
  7: **Goal**: Re-implement the Python-based Transparent Classroom Photos Grabber in Rust.
  8:
  9: 1. **Initialize Project**
 10:
 11:    * Create a new Cargo project.
 12:    * Set up the crate structure (modules for config, client, caching, etc.).
 13:
 14: 2. **Configuration Management**
 15:
 16:    * Use Rust’s environment variable approach (`dotenv` crate).
 17:    * Provide an optional config file approach with Serde (JSON or TOML).
 18:    * Expose a `Config` struct to hold application-wide settings.
 19:
 20: 3. **Logging & Error Handling**
 21:
 22:    * Establish a standard logging pattern (e.g., `log`, `env_logger`, or `tracing`).
 23:    * Add basic error types (`thiserror` crate or a custom error enum).
 24:
 25: 4. **HTTP Client & Basic Auth**
 26:
 27:    * Use `reqwest` for HTTP calls (blocking or async).
 28:    * Implement a minimal “login” functionality to replicate the Python `_login` approach.
 29:
 30: 5. **Caching**
 31:
 32:    * Store JSON responses on disk with a timestamp (via `serde_json`).
 33:    * Provide logic to read from cache if valid, else re-fetch.
 34:    * Include tests for caching edge cases (expired cache, missing files, no disk space, etc.).
 35:
 36: 6. **HTML Parsing**
 37:
 38:    * Use `scraper` or similar to parse the returned HTML, e.g., extracting CSRF tokens.
 39:    * Write a few tests for parsing.
 40:
 41: 7. **Rate Limiting**
 42:
 43:    * Implement a rate-limited approach to requests (if needed).
 44:    * Create basic tests confirming we do not exceed request frequency.
 45:
 46: 8. **Download & Metadata**
 47:
 48:    * Decide on approach: either wrap `exiftool` calls or use a pure-Rust library (e.g., `rexif` for EXIF).
 49:    * Add tests to confirm embedded metadata.
 50:    * Handle image format conversions if needed (like HEIF to JPEG).
 51:
 52: 9. **Integration & CLI**
 53:
 54:    * Build out a main function that pulls the flow together:
 55:
 56:      1. Load config.
 57:      2. Login.
 58:      3. Crawl pages.
 59:      4. Download & embed each photo.
 60:    * Provide an end-to-end integration test.
 61:
 62: ---
 63:
 64: ## 2. Break into Iterative Chunks
 65:
 66: Below is one possible breakdown into **eight** chunks, each chunk containing a small set of tasks you can implement, test, and refine before moving on.
 67:
 68: 1. **Chunk A**: Project Setup & Basic Tests
 69:
 70:    * Create new Cargo project.
 71:    * Set up a basic module structure.
 72:    * Write a trivial test to ensure that the project builds and runs.
 73:
 74: 2. **Chunk B**: Configuration Loading
 75:
 76:    * Add `dotenv` + `serde` + `serde_json` crates.
 77:    * Create a `Config` struct in `config.rs`.
 78:    * Load from environment variables (with fallback to file).
 79:    * Write tests that confirm env variables are read correctly.
 80:
 81: 3. **Chunk C**: Logging & Error Handling
 82:
 83:    * Add a `logger` module or just set up a global logger via `env_logger`.
 84:    * Define a custom `Error` enum or use `thiserror`.
 85:    * Write tests that confirm logs are emitted properly (smoke tests).
 86:
 87: 4. **Chunk D**: Basic HTTP & Session
 88:
 89:    * Add `reqwest` (blocking or async).
 90:    * Initialize a “client” struct to store cookies (session).
 91:    * Write tests for a trivial HTTP GET call with a mock server if needed.
 92:
 93: 5. **Chunk E**: Login Flow
 94:
 95:    * Implement the `_login` logic: fetch CSRF token, post credentials, verify success.
 96:    * Write tests with a local test server or by mocking.
 97:
 98: 6. **Chunk F**: Caching
 99:
100:    * Implement the caching logic (read JSON from disk, check timestamps).
101:    * Use `serde_json` to store responses.
102:    * Write tests for cache misses, hits, expiration.
103:
104: 7. **Chunk G**: Crawling & HTML Parsing
105:
106:    * Add the code that iterates pages and uses `scraper` or similar to parse the data.
107:    * Write tests that parse the HTML content for things like author, date, photo URLs.
108:
109: 8. **Chunk H**: Download, Metadata, & Integration
110:
111:    * Implement downloading photos, embedding metadata (via external tool calls or Rust library).
112:    * Ensure file renaming, timestamps, etc.
113:    * Write final integration tests that confirm end-to-end behavior.
114:
115: ---
116:
117: ## 3. Further Subdivision into Smaller Steps
118:
119: Here’s an example of how you might subdivide one of these chunks into more granular tasks. We’ll pick **Chunk E** (Login Flow) as an example:
120:
121: 1. **E1** - Add an integration test that attempts a “login” function call.
122: 2. **E2** - Create a `login()` stub in the client module that just returns `Ok(())`.
123: 3. **E3** - Fill out the code to do a basic GET request for the login page, returning the raw HTML.
124: 4. **E4** - Parse the HTML, extract the CSRF token (return an error if not found).
125: 5. **E5** - Send the POST request with credentials and token.
126: 6. **E6** - Return an error if login fails or if the server complains.
127: 7. **E7** - Confirm in the test that a success message or a correct cookie indicates we’re logged in.
128:
129: You would do similar breakdowns for caching, crawling, etc. Each step is small enough to test quickly and safely.
130:
131: ---
132:
133: ## 4. Final Prompts for Code Generation
134:
135: Below is a fictional example of how you might provide prompts to a code-generation LLM. Each prompt is designed to be self-contained and build on prior steps. They’re labeled with triple-backticks for clarity. Adjust as needed for your actual codebase and preference.
136:
137: ---
138:
139: ### **Prompt A1**: *Initialize Cargo Project and Basic Tests* (COMPLETED)
140:
141: ```
142: You are an AI coding assistant. We are building a Rust project called "transparent-classroom-grabber".
143: First, create a new Cargo library project with the following files:
144:
145: 1. Cargo.toml
146: 2. src/lib.rs
147: 3. tests/smoke_test.rs
148:
149: The library should compile and pass a trivial test in `tests/smoke_test.rs`.
150:
151: Please provide the complete file contents, with any necessary placeholders (like version, authors, etc.).
152: Use the 2021 edition of Rust and no default features.
153: ```
154:
155: ---
156:
157: ### **Prompt A2**: *Config Module & Tests*
158:
159: ```
160: We have a Rust project with a library. Now add a new file `src/config.rs` that defines a `Config` struct.
161: It should have:
162: - `email: String`
163: - `password: String`
164: - `school_id: u32`
165: - `child_id: u32`
166:
167: We want to load these from environment variables `TC_EMAIL`, `TC_PASSWORD`, `SCHOOL`, and `CHILD`.
168: If they are missing, return an error.
169: Use `dotenv` and `std::env::var`.
170: Define a function `Config::from_env() -> Result<Self, ConfigError>` that loads them.
171:
172: Then, in `tests/config_test.rs`, write unit tests that check:
173: 1) We can load a valid config from environment variables.
174: 2) Missing environment variable triggers an error.
175:
176: Provide the full code for `src/config.rs`, the `ConfigError`, plus the tests in `tests/config_test.rs`.
177: ```
178:
179: ---
180:
181: ### **Prompt A3**: *Logging & Error Handling* (COMPLETED)
182:
183: ```
184: We have our project with a `Config` struct. Now we want to add logging and an error type for the whole app.
185: 1) Create `src/error.rs` with a custom enum `AppError` using `thiserror`.
186: 2) Integrate logging via `env_logger` in `lib.rs`’s `init()` function, which we’ll call from tests or main.
187:    - `init()` should just initialize `env_logger` once.
188: 3) Modify the `Config::from_env()` function to return `AppError` instead of `ConfigError`.
189:
190: Update any references to `ConfigError` in `tests/config_test.rs`.
191: Show all changed files.
192: ```
193:
194: ---
195:
196: ### **Prompt A4**: *HTTP Client & Basic Testing* (COMPLETED)
197:
198: ```
199: We have config and logging in place. Next, create a new file `src/client.rs` with a `Client` struct that stores:
200: - A `reqwest::blocking::Client`
201: - A reference to our `Config`
202:
203: Create a constructor `Client::new(config: Config) -> Self`.
204: In that constructor, build a `reqwest::blocking::Client` that uses a cookie store.
205:
206: In `tests/client_test.rs`, write tests to confirm we can instantiate `Client`.
207: For now, just check that creating the `Client` doesn’t panic.
208: ```
209:
210: ---
211:
212: ### **Prompt A5**: *Login Flow (GET & POST with CSRF)* (COMPLETED)
213:
214: ```
215: Now we implement the login flow.
216: In `src/client.rs`, add:
217: 1) A method `fn login(&self) -> Result<(), AppError>`.
218: 2) It should:
219:    - GET the sign_in page
220:    - Parse out the CSRF token from a meta tag (assume name="csrf-token")
221:    - POST credentials + token to the same page
222:    - Return an error if login appears to fail.
223:
224: Add a new test in `tests/client_test.rs` that mocks or fakes the sign_in page.
225: We can do that with the `mockito` crate.
226: Implement the test so that it expects:
227:    - GET to `/souls/sign_in`, returns a page with a token
228:    - POST to the same endpoint, returns success
229:    - We confirm `login()` returns `Ok(())`
230:
231: Provide complete updated code for `client.rs` and `client_test.rs`.
232: ```
233:
234: ---
235:
236: ### **Prompt A6**: *Caching with JSON on Disk* (COMPLETED)
237:
238: ```
239: Next, we add caching.
240: Create `src/cache.rs` with:
241: - A function `read_cache(path: &Path) -> Result<Option<CacheData>, AppError>`
242: - A function `write_cache(path: &Path, data: &CacheData) -> Result<(), AppError>`
243:
244: `CacheData` is a struct with:
245:    - `timestamp: SystemTime` (when it was written)
246:    - `payload: Vec<Post>` (just an example structure for storing posts)
247:
248: Include logic to skip loading if the cache is expired (older than some threshold from config).
249: Add unit tests in `tests/cache_test.rs` that confirm:
250:    - Writing + reading works
251:    - Expired cache returns `Ok(None)`
252:
253: Show full code for `cache.rs`, `cache_test.rs`, plus any changes to your error types or Cargo.toml.
254: ```
255:
256: ---
257:
258: ### **Prompt A7**: *Crawling & HTML Parsing* (COMPLETED)
259:
260: ```
261: In `src/client.rs`, add:
262: - `fn get_posts(&self, page: u32) -> Result<Vec<Post>, AppError>`
263:    - Make an HTTP GET request to the Transparent Classroom endpoint, parse JSON, return a vector of `Post`.
264:    - If needed, parse HTML if the endpoint returns HTML, or just parse JSON if it returns JSON.
265:    - For now, just return an empty vector or a mocked example.
266:
267: Add a new test in `tests/client_test.rs`:
268: - Mocks the /posts.json endpoint
269: - Returns sample JSON with a couple of “Post” items
270: - Confirms `get_posts()` returns them
271:
272: For HTML parsing, if you need to parse HTML from the response, use the `scraper` crate.
273: Show all relevant code.
274: ```
275:
276: ---
277:
278: ### **Prompt A8**: *Download Photos, Metadata, Integration* (COMPLETED)
279:
280: ```
281: Now we tie it all together:
282: 1) Implement `fn download_photo(&self, post: &Post) -> Result<(), AppError>` that:
283:    - Builds a download URL from the post info
284:    - GET the photo bytes
285:    - Writes them to disk (maybe a `photos/` folder)
286:    - Optionally calls an external command (exiftool) or a Rust library to embed metadata
287:
288: 2) In `tests/client_test.rs`, write an integration test that:
289:    - Mocks a photo download
290:    - Confirms the photo file is written
291:    - (If possible) checks that metadata is embedded
292:
293: 3) Add a `bin/main.rs` that:
294:    - Loads config
295:    - Inits logging
296:    - Creates client
297:    - Logs in
298:    - Fetches some posts
299:    - Downloads photos
300:
301: Show all changed or new files, ensuring the entire application can now be run end-to-end.
302: ```
303:
304: ---
305:
306: ## 5. Final Note
307:
308: With this structure, each **Prompt** represents a small deliverable for the LLM to generate code. You test it, refine if necessary, then move on to the next prompt. This ensures no orphaned code and keeps the project in a consistently buildable and testable state.
</file>

</files>
